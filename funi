-- Combined Apex Predictor + Camera Tracker (apex-driven vertical behavior)
-- LocalScript under StarterPlayerScripts

wait(1)

-- ========== SERVICES ==========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local gravity = Workspace.Gravity

-- ========== APEX PREDICTOR CONFIG ==========
local APC = {}
APC.IDLE_Y_OFFSET = 0.2
APC.IDLE_SMOOTH_ALPHA = 0.01
APC.SNAP_ON_LAND = true
APC.MIN_UPWARD_VELOCITY = 1
APC.MARKER_SIZE = Vector3.new(1.5, 1.5, 1.5)
APC.MARKER_TRANSPARENCY = 0.45

-- ========== CAMERA CONFIG ==========
local CAMERA = {}
CAMERA.FOV = 70
CAMERA.SpringStiffness = 240
CAMERA.SpringDamping = 13.5
CAMERA.YawMaxSpeed = math.rad(300)
CAMERA.PitchMaxSpeed = math.rad(200)
CAMERA.BaseJitterAmount = math.rad(0.005)
CAMERA.OvershootChancePerSecond = 0.06
CAMERA.OvershootAmount = math.rad(0.5)
CAMERA.ReactionDelay = 0.075
CAMERA.TimeDelay = 0.15
CAMERA.PredictionAmount = 0.16
CAMERA.VelocitySmoothing = 12
CAMERA.RawSmoothingTime = 0.015
CAMERA.VerticalPredictionMultiplier = 1
CAMERA.SwaySensitivity = 0.0005
CAMERA.SwayDecaySpeed = 1.5
CAMERA.PitchLimit = math.rad(80)
CAMERA.VisualizerDistance = 0.15
CAMERA.SnapAngle = math.rad(0.1)
CAMERA.SnapEnabled = true
CAMERA.TargetSwitchKey = Enum.KeyCode.T

Camera.FieldOfView = CAMERA.FOV

-- ========== UTIL ==========
local function clamp(val, lo, hi)
	if val < lo then return lo end
	if val > hi then return hi end
	return val
end

local function shortestAngleDiff(a, b)
	return math.atan2(math.sin(b - a), math.cos(b - a))
end

local function dirToYawPitch(dir)
	local y = math.clamp(dir.Y, -1, 1)
	local pitch = math.asin(y)
	local yaw = math.atan2(dir.X, dir.Z)
	return yaw, pitch
end

local function yawPitchToForward(yaw, pitch)
	local cp = math.cos(pitch)
	return Vector3.new(
		math.sin(yaw) * cp,
		math.sin(pitch),
		math.cos(yaw) * cp
	)
end

local function springUpdate(current, target, velocity, stiffness, damping, dt)
	local force = shortestAngleDiff(current, target) * stiffness
	local dampingForce = velocity * damping
	local accel = force - dampingForce
	velocity = velocity + accel * dt
	current = current + velocity * dt
	return current, velocity
end

local function clampVel(vel, maxVel)
	return math.clamp(vel, -maxVel, maxVel)
end

local function snapAngle(angle, snapStep)
	return math.round(angle / snapStep) * snapStep
end

-- ========== MARKER ==========
local function createMarker(player)
	local part = Instance.new("Part")
	part.Name = "Prediction_" .. player.Name
	part.Anchored = true
	part.CanCollide = false
	part.Shape = Enum.PartType.Ball
	part.Size = APC.MARKER_SIZE
	part.Material = Enum.Material.SmoothPlastic
	part.Transparency = APC.MARKER_TRANSPARENCY
	part.Parent = Workspace
	return part
end

-- ========== APEX PREDICTION MATH ==========
local function predictApexY(currentY, velocityY)
	if velocityY <= 0 then
		return currentY
	end
	local t = velocityY / gravity
	return currentY + velocityY * t - 0.5 * gravity * (t * t)
end

-- ========== TRACKING STORAGE ==========
-- tracked[player] = { marker=Part, predicted=bool, apexY=number, currentIdleY=number, landed=bool, history = { {time,pos,vel}, ... } }
local tracked = {}

local function trackPlayer(player)
	if player == localPlayer then return end
	if tracked[player] then return end
	local marker = createMarker(player)
	tracked[player] = {
		marker = marker,
		predicted = false,
		apexY = nil,
		currentIdleY = nil,
		landed = false,
		history = {},
	}
end

local function untrackPlayer(player)
	local data = tracked[player]
	if not data then return end
	if data.marker then
		pcall(function() data.marker:Destroy() end)
	end
	tracked[player] = nil
end

Players.PlayerAdded:Connect(trackPlayer)
Players.PlayerRemoving:Connect(untrackPlayer)
for _, pl in ipairs(Players:GetPlayers()) do
	trackPlayer(pl)
end

-- ========== CAMERA STATE ==========
local yaw, pitch = 0, 0
local yawVel, pitchVel = 0, 0
local delayedYaw, delayedPitch = 0, 0
local reactionTimer = 0
local positionHistory = {}
local smoothedVelocity = Vector3.new(0,0,0)
local swayStrength = CAMERA.BaseJitterAmount

local visualizer = Instance.new("Part")
visualizer.Anchored = true
visualizer.CanCollide = false
visualizer.Size = Vector3.new(0.001, 0.001, 0.001)
visualizer.Shape = Enum.PartType.Ball
visualizer.Material = Enum.Material.Neon
visualizer.Parent = workspace

local rng = Random.new()

local currentTargetPlayer = nil

local function getCharParts(player)
	if not player then return nil end
	local ch = player.Character
	if not ch or not ch.Parent then return nil end
	local head = ch:FindFirstChild("Head")
	local hrp = ch:FindFirstChild("HumanoidRootPart")
	local humanoid = ch:FindFirstChildOfClass("Humanoid")
	if not head or not hrp or not humanoid then return nil end
	return head, hrp, humanoid
end

-- ========== TARGET SELECTION (T) ==========
local mouse = localPlayer:GetMouse()

local function combinedDistanceToPlayer(player, camPos, mousePos)
	local head, _, _ = getCharParts(player)
	if not head then return math.huge end
	local hpos = head.Position
	local camDist = (hpos - camPos).Magnitude
	local mouseDist = (hpos - mousePos).Magnitude
	return camDist + mouseDist
end

local function selectClosestPlayerCycle()
	local camPos = Camera.CFrame.Position
	local mousePos
	local ok, p = pcall(function() return mouse.Hit and mouse.Hit.p end)
	if ok and p then
		mousePos = p
	else
		mousePos = camPos + Camera.CFrame.LookVector * 50
	end

	local list = {}
	for _, pl in ipairs(Players:GetPlayers()) do
		if pl ~= localPlayer then
			local head = pl.Character and pl.Character:FindFirstChild("Head")
			if head and head.Parent then
				local score = combinedDistanceToPlayer(pl, camPos, mousePos)
				table.insert(list, {player = pl, score = score})
			end
		end
	end

	if #list == 0 then
		currentTargetPlayer = nil
		positionHistory = {}
		return
	end

	table.sort(list, function(a,b) return a.score < b.score end)

	if not currentTargetPlayer then
		currentTargetPlayer = list[1].player
		positionHistory = {}
		smoothedVelocity = Vector3.new(0,0,0)
		reactionTimer = 0
		return
	end

	if list[1].player == currentTargetPlayer then
		local idx = nil
		for i, entry in ipairs(list) do
			if entry.player == currentTargetPlayer then
				idx = i
				break
			end
		end
		local nextIndex = (idx and idx % #list + 1) or 1
		currentTargetPlayer = list[nextIndex].player
		positionHistory = {}
		smoothedVelocity = Vector3.new(0,0,0)
		reactionTimer = 0
		return
	else
		currentTargetPlayer = list[1].player
		positionHistory = {}
		smoothedVelocity = Vector3.new(0,0,0)
		reactionTimer = 0
		return
	end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == CAMERA.TargetSwitchKey then
		selectClosestPlayerCycle()
	end
end)

-- ========== HEARTBEAT: marker + apex + sampling ==========
RunService.Heartbeat:Connect(function()
	for player, data in pairs(tracked) do
		if not data or not data.marker then
			tracked[player] = nil
		else
			local char = player.Character
			local marker = data.marker

			if not char or not char.Parent then
				data.predicted = false
				data.apexY = nil
				data.currentIdleY = nil
				data.landed = false
				data.history = {}
			else
				local humanoid = char:FindFirstChildOfClass("Humanoid")
				local hrp = char:FindFirstChild("HumanoidRootPart")
				local head = char:FindFirstChild("Head")

				if not humanoid or not hrp or not head then
					-- skip this frame
				else
					local headPos = head.Position
					local grounded = humanoid.FloorMaterial ~= Enum.Material.Air

					-- sample: store head pos and HRP velocity for later delayed-anchored velocity readout
					local now = tick()er(pl)
				end

				-- ========== CAMERA STATE ==========
				local yaw, pitch = 0, 0
				local yawVel, pitchVel = 0, 0
				local delayedYaw, delayedPitch = 0, 0
				local reactionTimer = 0
				local positionHistory = {}
				local smoothedVelocity = Vector3.new(0,0,0)
				local swayStrength = CAMERA.BaseJitterAmount

				local visualizer = Instance.new("Part")
				visualizer.Anchored = true
				visualizer.CanCollide = false
				visualizer.Size = Vector3.new(0.001, 0.001, 0.001)
				visualizer.Shape = Enum.PartType.Ball
				visualizer.Material = Enum.Material.Neon
				visualizer.Parent = workspace

				local rng = Random.new()

				local currentTargetPlayer = nil

				local function getCharParts(player)
					if not player then return nil end
					local ch = player.Character
					if not ch or not ch.Parent then return nil end
					local head = ch:FindFirstChild("Head")
					local hrp = ch:FindFirstChild("HumanoidRootPart")
					local humanoid = ch:FindFirstChildOfClass("Humanoid")
					if not head or not hrp or not humanoid then return nil end
					return head, hrp, humanoid
				end

				-- ========== TARGET SELECTION (T) ==========
				local mouse = localPlayer:GetMouse()

				local function combinedDistanceToPlayer(player, camPos, mousePos)
					local head, _, _ = getCharParts(player)
					if not head then return math.huge end
					local hpos = head.Position
					local camDist = (hpos - camPos).Magnitude
					local mouseDist = (hpos - mousePos).Magnitude
					return camDist + mouseDist
				end

				local function selectClosestPlayerCycle()
					local camPos = Camera.CFrame.Position
					local mousePos
					local ok, p = pcall(function() return mouse.Hit and mouse.Hit.p end)
					if ok and p then
						mousePos = p
					else
						mousePos = camPos + Camera.CFrame.LookVector * 50
					end

					local list = {}
					for _, pl in ipairs(Players:GetPlayers()) do
						if pl ~= localPlayer then
							local head = pl.Character and pl.Character:FindFirstChild("Head")
							if head and head.Parent then
								local score = combinedDistanceToPlayer(pl, camPos, mousePos)
								table.insert(list, {player = pl, score = score})
							end
						end
					end

					if #list == 0 then
						currentTargetPlayer = nil
						positionHistory = {}
						return
					end

					table.sort(list, function(a,b) return a.score < b.score end)

					if not currentTargetPlayer then
						currentTargetPlayer = list[1].player
						positionHistory = {}
						smoothedVelocity = Vector3.new(0,0,0)
						reactionTimer = 0
						return
					end

					if list[1].player == currentTargetPlayer then
						local idx = nil
						for i, entry in ipairs(list) do
							if entry.player == currentTargetPlayer then
								idx = i
								break
							end
						end
						local nextIndex = (idx and idx % #list + 1) or 1
						currentTargetPlayer = list[nextIndex].player
						positionHistory = {}
						smoothedVelocity = Vector3.new(0,0,0)
						reactionTimer = 0
						return
					else
						currentTargetPlayer = list[1].player
						positionHistory = {}
						smoothedVelocity = Vector3.new(0,0,0)
						reactionTimer = 0
						return
					end
				end

				UserInputService.InputBegan:Connect(function(input, gameProcessed)
					if gameProcessed then return end
					if input.KeyCode == CAMERA.TargetSwitchKey then
						selectClosestPlayerCycle()
					end
				end)

				-- ========== HEARTBEAT: marker + apex + sampling ==========
				RunService.Heartbeat:Connect(function()
					for player, data in pairs(tracked) do
						if not data or not data.marker then
							tracked[player] = nil
						else
							local char = player.Character
							local marker = data.marker

							if not char or not char.Parent then
								data.predicted = false
								data.apexY = nil
								data.currentIdleY = nil
								data.landed = false
								data.history = {}
							else
								local humanoid = char:FindFirstChildOfClass("Humanoid")
								local hrp = char:FindFirstChild("HumanoidRootPart")
								local head = char:FindFirstChild("Head")

								if not humanoid or not hrp or not head then
									-- skip this frame
								else
									local headPos = head.Position
									local grounded = humanoid.FloorMaterial ~= Enum.Material.Air

									-- sample: store head pos and HRP velocity for later delayed-anchored velocity readout
									local now = tick()
									table.insert(data.history, { time = now, pos = headPos, vel = hrp.Velocity })
									while #data.history > 0 and now - data.history[1].time > CAMERA.TimeDelay + 0.5 do
										table.remove(data.history, 1)
									end

									-- marker behavior (apex predictor)
									if grounded then
										if APC.SNAP_ON_LAND and data.landed == false then
											marker.Position = Vector3.new(headPos.X, headPos.Y + APC.IDLE_Y_OFFSET, headPos.Z)
											data.currentIdleY = headPos.Y + APC.IDLE_Y_OFFSET
											data.landed = true
										else
											if not data.currentIdleY then
												data.currentIdleY = headPos.Y + APC.IDLE_Y_OFFSET
											else
												data.currentIdleY = data.currentIdleY + (headPos.Y + APC.IDLE_Y_OFFSET - data.currentIdleY) * APC.IDLE_SMOOTH_ALPHA
											end
											marker.Position = Vector3.new(headPos.X, data.currentIdleY, headPos.Z)
										end

										data.predicted = false
										data.apexY = nil
									else
										data.landed = false

										if not data.predicted then
											local vY = hrp.Velocity and hrp.Velocity.Y or 0
											if vY > APC.MIN_UPWARD_VELOCITY then
												data.predicted = true
												data.apexY = predictApexY(headPos.Y, vY)
												-- place the marker at apex (instantly)
												marker.Position = Vector3.new(headPos.X, data.apexY, headPos.Z)
											else
												marker.Position = Vector3.new(headPos.X, marker.Position.Y, headPos.Z)
											end
										else
											if data.apexY then
												marker.Position = Vector3.new(headPos.X, data.apexY, headPos.Z)
											else
												marker.Position = Vector3.new(headPos.X, marker.Position.Y, headPos.Z)
											end
										end
									end
								end
							end
						end
					end
				end)

				-- ========== RENDERSTEPPED: camera aiming (apex-locked vertical behavior) ==========
				RunService.RenderStepped:Connect(function(dt)
					if not currentTargetPlayer then
						return
					end

					local data = tracked[currentTargetPlayer]
					if not data then
						trackPlayer(currentTargetPlayer)
						return
					end

					local head, hrp, humanoid = getCharParts(currentTargetPlayer)
					if not head or not hrp or not humanoid then
						return
					end

					local camPos = Camera.CFrame.Position
					local targetPos = head.Position
					local now = tick()

					-- build/refresh local positionHistory from the per-player history if we just switched or are empty
					positionHistory = positionHistory or {}
					if #positionHistory == 0 and #data.history > 0 then
						for i = math.max(1, #data.history - 30), #data.history do
							table.insert(positionHistory, { time = data.history[i].time, pos = data.history[i].pos })
						end
					end

					-- append current head pos
					table.insert(positionHistory, { time = now, pos = targetPos })
					while #positionHistory > 0 and now - positionHistory[1].time > CAMERA.TimeDelay + 0.5 do
						table.remove(positionHistory, 1)
					end

					-- find delayed position sample (closest sample older than TimeDelay)
					local delayedPos = targetPos
					local delayedIndex = #positionHistory
					for i = 1, #positionHistory do
						if now - positionHistory[i].time >= CAMERA.TimeDelay then
							delayedPos = positionHistory[i].pos
							delayedIndex = i
						else
							break
						end
					end

					-- velocity anchored at delayed sample: prefer hrp velocity from data.history
					local velocityAtDelayed = Vector3.zero
					if #data.history >= 1 then
						local targetTime = now - CAMERA.TimeDelay
						local bestIdx, bestDelta = nil, math.huge
						for i = 1, #data.history do
							local delta = math.abs(targetTime - data.history[i].time)
							if delta < bestDelta then
								bestDelta = delta
								bestIdx = i
							end
						end
						if bestIdx then
							velocityAtDelayed = data.history[bestIdx].vel or Vector3.zero
							-- prefer delayedPos from data.history sample if close in time
							if data.history[bestIdx].pos and math.abs((now - CAMERA.TimeDelay) - data.history[bestIdx].time) < 0.05 then
								delayedPos = data.history[bestIdx].pos
							end
						end
					else
						-- fallback to numeric derivative on positionHistory
						if #positionHistory >= 2 then
							local cur = positionHistory[#positionHistory]
							local prev = positionHistory[#positionHistory - 1]
							local histDt = cur.time - prev.time
							if histDt > 0 then
								velocityAtDelayed = (cur.pos - prev.pos) / histDt
							end
						end
					end

					-- === APEX-FIRST VERTICAL RULE ===
					-- If predictor lock exists (apex predicted) and target is airborne, lock vertical target to apex:
					local predictedPos
					local targetAirborne = humanoid.FloorMaterial == Enum.Material.Air
					if data.predicted and data.apexY and targetAirborne then
						-- Use apex Y as the vertical aim. Keep X/Z based on delayed/predicted logic below.
						-- For X/Z we still use the delayed sample + horizontal velocity prediction.
						-- Compute smoothed horizontal velocity (ignore Y here because apex supplies Y).
						local horizVel = Vector3.new(velocityAtDelayed.X, 0, velocityAtDelayed.Z)
						local velAlpha = 1 - math.exp(-CAMERA.VelocitySmoothing * dt)
						local prevSmoothed = smoothedVelocity
						-- Only smooth horizontal components onto smoothedVelocity, keep Y zero (apex-driven)
						smoothedVelocity = Vector3.new(
							prevSmoothed.X + (horizVel.X - prevSmoothed.X) * velAlpha,
							0,
							prevSmoothed.Z + (horizVel.Z - prevSmoothed.Z) * velAlpha
						)

						-- predicted X/Z from horizontal velocity; Y fixed to apex
						local predictedXZ = Vector3.new(
							delayedPos.X + smoothedVelocity.X * CAMERA.PredictionAmount,
							data.apexY,
							delayedPos.Z + smoothedVelocity.Z * CAMERA.PredictionAmount
						)
						predictedPos = predictedXZ
					else
						-- fallback: the previous behavior (delayed anchored velocity prediction)
						local velAlpha = 1 - math.exp(-CAMERA.VelocitySmoothing * dt)
						smoothedVelocity = smoothedVelocity + (velocityAtDelayed - smoothedVelocity) * velAlpha

						local predictiveVel = Vector3.new(
							smoothedVelocity.X,
							smoothedVelocity.Y * CAMERA.VerticalPredictionMultiplier,
							smoothedVelocity.Z
						)
						predictedPos = delayedPos + predictiveVel * CAMERA.PredictionAmount

						-- If grounded and we have a smoothed idle Y in the tracked data, prefer that Y so camera and marker align
						if not targetAirborne and data.currentIdleY then
							-- blend toward the idleY a little to avoid snaps
							local blendAlpha = 0.5 -- moderate blending to keep camera stable while following head
							predictedPos = Vector3.new(predictedPos.X, predictedPos.Y * (1 - blendAlpha) + data.currentIdleY * blendAlpha, predictedPos.Z)
						end
					end

					-- Safety: avoid degenerate direction
					local toTarget = predictedPos - camPos
					if toTarget.Magnitude < 1e-5 then return end
					local targetYaw, targetPitch = dirToYawPitch(toTarget.Unit)

					-- reaction ramp and smoothing
					reactionTimer = math.min(reactionTimer + dt, CAMERA.ReactionDelay)
					local smoothingTime = math.max(1e-4, CAMERA.RawSmoothingTime)
					local baseSmoothAlpha = 1 - math.exp(-dt / smoothingTime)
					local ramp = math.clamp(reactionTimer / CAMERA.ReactionDelay, 0, 1)
					local effectiveAlpha = baseSmoothAlpha * ramp

					delayedYaw = delayedYaw + shortestAngleDiff(delayedYaw, targetYaw) * effectiveAlpha
					delayedPitch = delayedPitch + shortestAngleDiff(delayedPitch, targetPitch) * effectiveAlpha

					if rng:NextNumber() < CAMERA.OvershootChancePerSecond * dt then
						delayedYaw = delayedYaw + rng:NextNumber(-CAMERA.OvershootAmount, CAMERA.OvershootAmount)
						delayedPitch = delayedPitch + rng:NextNumber(-CAMERA.OvershootAmount, CAMERA.OvershootAmount)
					end

					local verticalSpeed = smoothedVelocity:Dot(Vector3.new(0, 1, 0))
					local targetVerticalFactor = math.abs(verticalSpeed) * CAMERA.SwaySensitivity
					swayStrength = swayStrength + (targetVerticalFactor - swayStrength) * math.min(1, CAMERA.SwayDecaySpeed * dt)
					swayStrength = math.max(CAMERA.BaseJitterAmount, swayStrength)

					yaw, yawVel = springUpdate(yaw, delayedYaw, yawVel, CAMERA.SpringStiffness, CAMERA.SpringDamping, dt)
					pitch, pitchVel = springUpdate(pitch, delayedPitch, pitchVel, CAMERA.SpringStiffness, CAMERA.SpringDamping, dt)

					yawVel = clampVel(yawVel, CAMERA.YawMaxSpeed)
					pitchVel = clampVel(pitchVel, CAMERA.PitchMaxSpeed)

					local jitterYaw = math.sin(now * 16.42) * swayStrength
					local jitterPitch = math.cos(now * 8.13) * swayStrength

					local finalYaw = yaw + jitterYaw
					local finalPitch = math.clamp(pitch + jitterPitch, -CAMERA.PitchLimit, CAMERA.PitchLimit)

					if CAMERA.SnapEnabled then
						finalYaw = snapAngle(finalYaw, CAMERA.SnapAngle)
						finalPitch = snapAngle(finalPitch, CAMERA.SnapAngle)
					end

					local forward = yawPitchToForward(finalYaw, finalPitch)
					Camera.CFrame = CFrame.new(camPos, camPos + forward)

					local rawForward = yawPitchToForward(delayedYaw, delayedPitch)
					local visPos = camPos + rawForward * CAMERA.VisualizerDistance
					visualizer.Position = visPos
				end)

					table.insert(data.history, { time = now, pos = headPos, vel = hrp.Velocity })
					while #data.history > 0 and now - data.history[1].time > CAMERA.TimeDelay + 0.5 do
						table.remove(data.history, 1)
					end

					-- marker behavior (apex predictor)
					if grounded then
						if APC.SNAP_ON_LAND and data.landed == false then
							marker.Position = Vector3.new(headPos.X, headPos.Y + APC.IDLE_Y_OFFSET, headPos.Z)
							data.currentIdleY = headPos.Y + APC.IDLE_Y_OFFSET
							data.landed = true
						else
							if not data.currentIdleY then
								data.currentIdleY = headPos.Y + APC.IDLE_Y_OFFSET
							else
								data.currentIdleY = data.currentIdleY + (headPos.Y + APC.IDLE_Y_OFFSET - data.currentIdleY) * APC.IDLE_SMOOTH_ALPHA
							end
							marker.Position = Vector3.new(headPos.X, data.currentIdleY, headPos.Z)
						end

						data.predicted = false
						data.apexY = nil
					else
						data.landed = false

						if not data.predicted then
							local vY = hrp.Velocity and hrp.Velocity.Y or 0
							if vY > APC.MIN_UPWARD_VELOCITY then
								data.predicted = true
								data.apexY = predictApexY(headPos.Y, vY)
								-- place the marker at apex (instantly)
								marker.Position = Vector3.new(headPos.X, data.apexY, headPos.Z)
							else
								marker.Position = Vector3.new(headPos.X, marker.Position.Y, headPos.Z)
							end
						else
							if data.apexY then
								marker.Position = Vector3.new(headPos.X, data.apexY, headPos.Z)
							else
								marker.Position = Vector3.new(headPos.X, marker.Position.Y, headPos.Z)
							end
						end
					end
				end
			end
		end
	end
end)

-- ========== RENDERSTEPPED: camera aiming (apex-locked vertical behavior) ==========
RunService.RenderStepped:Connect(function(dt)
	if not currentTargetPlayer then
		return
	end

	local data = tracked[currentTargetPlayer]
	if not data then
		trackPlayer(currentTargetPlayer)
		return
	end

	local head, hrp, humanoid = getCharParts(currentTargetPlayer)
	if not head or not hrp or not humanoid then
		return
	end

	local camPos = Camera.CFrame.Position
	local targetPos = head.Position
	local now = tick()

	-- build/refresh local positionHistory from the per-player history if we just switched or are empty
	positionHistory = positionHistory or {}
	if #positionHistory == 0 and #data.history > 0 then
		for i = math.max(1, #data.history - 30), #data.history do
			table.insert(positionHistory, { time = data.history[i].time, pos = data.history[i].pos })
		end
	end

	-- append current head pos
	table.insert(positionHistory, { time = now, pos = targetPos })
	while #positionHistory > 0 and now - positionHistory[1].time > CAMERA.TimeDelay + 0.5 do
		table.remove(positionHistory, 1)
	end

	-- find delayed position sample (closest sample older than TimeDelay)
	local delayedPos = targetPos
	local delayedIndex = #positionHistory
	for i = 1, #positionHistory do
		if now - positionHistory[i].time >= CAMERA.TimeDelay then
			delayedPos = positionHistory[i].pos
			delayedIndex = i
		else
			break
		end
	end

	-- velocity anchored at delayed sample: prefer hrp velocity from data.history
	local velocityAtDelayed = Vector3.zero
	if #data.history >= 1 then
		local targetTime = now - CAMERA.TimeDelay
		local bestIdx, bestDelta = nil, math.huge
		for i = 1, #data.history do
			local delta = math.abs(targetTime - data.history[i].time)
			if delta < bestDelta then
				bestDelta = delta
				bestIdx = i
			end
		end
		if bestIdx then
			velocityAtDelayed = data.history[bestIdx].vel or Vector3.zero
			-- prefer delayedPos from data.history sample if close in time
			if data.history[bestIdx].pos and math.abs((now - CAMERA.TimeDelay) - data.history[bestIdx].time) < 0.05 then
				delayedPos = data.history[bestIdx].pos
			end
		end
	else
		-- fallback to numeric derivative on positionHistory
		if #positionHistory >= 2 then
			local cur = positionHistory[#positionHistory]
			local prev = positionHistory[#positionHistory - 1]
			local histDt = cur.time - prev.time
			if histDt > 0 then
				velocityAtDelayed = (cur.pos - prev.pos) / histDt
			end
		end
	end

	-- === APEX-FIRST VERTICAL RULE ===
	-- If predictor lock exists (apex predicted) and target is airborne, lock vertical target to apex:
	local predictedPos
	local targetAirborne = humanoid.FloorMaterial == Enum.Material.Air
	if data.predicted and data.apexY and targetAirborne then
		-- Use apex Y as the vertical aim. Keep X/Z based on delayed/predicted logic below.
		-- For X/Z we still use the delayed sample + horizontal velocity prediction.
		-- Compute smoothed horizontal velocity (ignore Y here because apex supplies Y).
		local horizVel = Vector3.new(velocityAtDelayed.X, 0, velocityAtDelayed.Z)
		local velAlpha = 1 - math.exp(-CAMERA.VelocitySmoothing * dt)
		local prevSmoothed = smoothedVelocity
		-- Only smooth horizontal components onto smoothedVelocity, keep Y zero (apex-driven)
		smoothedVelocity = Vector3.new(
			prevSmoothed.X + (horizVel.X - prevSmoothed.X) * velAlpha,
			0,
			prevSmoothed.Z + (horizVel.Z - prevSmoothed.Z) * velAlpha
		)

		-- predicted X/Z from horizontal velocity; Y fixed to apex
		local predictedXZ = Vector3.new(
			delayedPos.X + smoothedVelocity.X * CAMERA.PredictionAmount,
			data.apexY,
			delayedPos.Z + smoothedVelocity.Z * CAMERA.PredictionAmount
		)
		predictedPos = predictedXZ
	else
		-- fallback: the previous behavior (delayed anchored velocity prediction)
		local velAlpha = 1 - math.exp(-CAMERA.VelocitySmoothing * dt)
		smoothedVelocity = smoothedVelocity + (velocityAtDelayed - smoothedVelocity) * velAlpha

		local predictiveVel = Vector3.new(
			smoothedVelocity.X,
			smoothedVelocity.Y * CAMERA.VerticalPredictionMultiplier,
			smoothedVelocity.Z
		)
		predictedPos = delayedPos + predictiveVel * CAMERA.PredictionAmount

		-- If grounded and we have a smoothed idle Y in the tracked data, prefer that Y so camera and marker align
		if not targetAirborne and data.currentIdleY then
			-- blend toward the idleY a little to avoid snaps
			local blendAlpha = 0.5 -- moderate blending to keep camera stable while following head
			predictedPos = Vector3.new(predictedPos.X, predictedPos.Y * (1 - blendAlpha) + data.currentIdleY * blendAlpha, predictedPos.Z)
		end
	end

	-- Safety: avoid degenerate direction
	local toTarget = predictedPos - camPos
	if toTarget.Magnitude < 1e-5 then return end
	local targetYaw, targetPitch = dirToYawPitch(toTarget.Unit)

	-- reaction ramp and smoothing
	reactionTimer = math.min(reactionTimer + dt, CAMERA.ReactionDelay)
	local smoothingTime = math.max(1e-4, CAMERA.RawSmoothingTime)
	local baseSmoothAlpha = 1 - math.exp(-dt / smoothingTime)
	local ramp = math.clamp(reactionTimer / CAMERA.ReactionDelay, 0, 1)
	local effectiveAlpha = baseSmoothAlpha * ramp

	delayedYaw = delayedYaw + shortestAngleDiff(delayedYaw, targetYaw) * effectiveAlpha
	delayedPitch = delayedPitch + shortestAngleDiff(delayedPitch, targetPitch) * effectiveAlpha

	if rng:NextNumber() < CAMERA.OvershootChancePerSecond * dt then
		delayedYaw = delayedYaw + rng:NextNumber(-CAMERA.OvershootAmount, CAMERA.OvershootAmount)
		delayedPitch = delayedPitch + rng:NextNumber(-CAMERA.OvershootAmount, CAMERA.OvershootAmount)
	end

	local verticalSpeed = smoothedVelocity:Dot(Vector3.new(0, 1, 0))
	local targetVerticalFactor = math.abs(verticalSpeed) * CAMERA.SwaySensitivity
	swayStrength = swayStrength + (targetVerticalFactor - swayStrength) * math.min(1, CAMERA.SwayDecaySpeed * dt)
	swayStrength = math.max(CAMERA.BaseJitterAmount, swayStrength)

	yaw, yawVel = springUpdate(yaw, delayedYaw, yawVel, CAMERA.SpringStiffness, CAMERA.SpringDamping, dt)
	pitch, pitchVel = springUpdate(pitch, delayedPitch, pitchVel, CAMERA.SpringStiffness, CAMERA.SpringDamping, dt)

	yawVel = clampVel(yawVel, CAMERA.YawMaxSpeed)
	pitchVel = clampVel(pitchVel, CAMERA.PitchMaxSpeed)

	local jitterYaw = math.sin(now * 16.42) * swayStrength
	local jitterPitch = math.cos(now * 8.13) * swayStrength

	local finalYaw = yaw + jitterYaw
	local finalPitch = math.clamp(pitch + jitterPitch, -CAMERA.PitchLimit, CAMERA.PitchLimit)

	if CAMERA.SnapEnabled then
		finalYaw = snapAngle(finalYaw, CAMERA.SnapAngle)
		finalPitch = snapAngle(finalPitch, CAMERA.SnapAngle)
	end

	local forward = yawPitchToForward(finalYaw, finalPitch)
	Camera.CFrame = CFrame.new(camPos, camPos + forward)

	local rawForward = yawPitchToForward(delayedYaw, delayedPitch)
	local visPos = camPos + rawForward * CAMERA.VisualizerDistance
	visualizer.Position = visPos
end)
