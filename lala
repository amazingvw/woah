-----------------------------------
-- CONFIGURATION
-----------------------------------
local MAX_SPEED         = 22.7
local COIN_BUFFER       = 1
local MAX_COIN_DISTANCE = 400

local STEER_SPRING  = 45
local STEER_DAMP    = 1
local ROT_SPRING    = 700
local ROT_DAMP      = 10

-----------------------------------
-- SERVICES
-----------------------------------
local Players            = game:GetService("Players")
local RunService         = game:GetService("RunService")
local player             = Players.LocalPlayer

-----------------------------------
-- COIN VALIDATION
-----------------------------------
local function isCoinValid(coinPart)
    -- Must be the server coin part
    if not coinPart:IsA("BasePart") or coinPart.Name ~= "Coin_Server" then
        return false
    end
    local vis = coinPart:FindFirstChild("CoinVisual")
    -- Must have CoinVisual and be visible
    return vis and vis:IsA("BasePart") and vis.Transparency <= 0.1
end

local function getClosestCoin(hrp)
    local closest, shortestDist = nil, math.huge
    for _, desc in ipairs(workspace:GetDescendants()) do
        if desc:IsA("BasePart") and desc.Name == "Coin_Server" and isCoinValid(desc) then
            local dist = (hrp.Position - desc.Position).Magnitude
            if dist < shortestDist and dist <= MAX_COIN_DISTANCE then
                shortestDist = dist
                closest = desc
            end
        end
    end
    return closest
end

-----------------------------------
-- MOVEMENT & COLLECTION
-----------------------------------
local function moveContinuously(char)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local dirVel, rotVel = Vector3.zero, Vector3.zero
    local forward = hrp.CFrame.LookVector
    local targetCoin

    while char.Parent do
        local dt = RunService.Heartbeat:Wait()

        -- pick or re-pick target
        if not targetCoin
           or not targetCoin:IsDescendantOf(workspace)
           or not isCoinValid(targetCoin) then
            targetCoin = getClosestCoin(hrp)
        end

        if targetCoin then
            local dist = (hrp.Position - targetCoin.Position).Magnitude
            local radius = targetCoin.Size.Magnitude/2 + COIN_BUFFER

            if dist <= radius then
                -- **COLLECT**: fade out
                for _, p in ipairs(targetCoin:GetDescendants()) do
                    if p:IsA("BasePart") then
                        p.Transparency = 0.5
                        p.CanCollide = false
                    end
                end
                targetCoin = nil
            else
                -- steering spring
                local desired = (targetCoin.Position - hrp.Position).Unit
                local dVel = desired - forward
                local steerAccel = dVel * STEER_SPRING
                dirVel = (dirVel + steerAccel * dt) * math.exp(-STEER_DAMP * dt)
                forward = (forward + dirVel * dt).Unit

                -- rotation spring
                local dLook = forward - hrp.CFrame.LookVector
                local aLook = dLook * ROT_SPRING
                rotVel = (rotVel + aLook * dt) * math.exp(-ROT_DAMP * dt)
                local lookDir = (hrp.CFrame.LookVector + rotVel * dt).Unit

                -- move character
                local newPos = hrp.Position + forward * MAX_SPEED * dt
                hrp.CFrame = CFrame.new(newPos, newPos + lookDir)
            end
        end
    end
end

-----------------------------------
-- NOCLIP
-----------------------------------
local NoclipConn
NoclipConn = RunService.Stepped:Connect(function()
    if player.Character then
        for _, v in ipairs(player.Character:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CanCollide = false
            end
        end
    end
end)

-----------------------------------
-- CHARACTER INIT + RESPAWN
-----------------------------------
local function onCharacterAdded(char)
    local humanoid = char:WaitForChild("Humanoid")
    char:WaitForChild("HumanoidRootPart")

    workspace.Gravity = 0
    humanoid.PlatformStand = true

    -- start movement loop
    task.defer(function()
        moveContinuously(char)
    end)
end

if player.Character then
    onCharacterAdded(player.Character)
end
player.CharacterAdded:Connect(onCharacterAdded)
