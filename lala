-----------------------------------
-- CONFIGURATION
-----------------------------------
local MAX_SPEED     = 22.7
local COIN_BUFFER   = 1
local MIN_DISTANCE  = 50  -- Set your desired threshold for when to move toward a coin (e.g., 50 studs)

local STEER_SPRING  = 45
local STEER_DAMP    = 1
local ROT_SPRING    = 700
local ROT_DAMP      = 10

-----------------------------------
-- SERVICES
-----------------------------------
local Players    = game:GetService("Players")
local RunService = game:GetService("RunService")
local player     = Players.LocalPlayer

-----------------------------------
-- COIN DETECTION + VALIDATION
-----------------------------------
local function isCoinValid(coinPart)
	if not coinPart:IsA("BasePart") or coinPart.Name ~= "Coin_Server" then return false end

	-- Check for MeshPart or CoinVisual child detection
	if coinPart:IsA("MeshPart") then
		-- If it is a MeshPart (Type 1 Coin), check if it's valid (not collected)
		for _, child in ipairs(coinPart:GetChildren()) do
			if child:IsA("BasePart") and child.Transparency > 0.1 then
				return false -- Already collected
			end
		end
	elseif coinPart.Name == "Coin_Server" then
		-- If Coin_Server has a "CoinVisual" inside it (Type 2 Coin)
		local coinVisual = coinPart:FindFirstChild("CoinVisual")
		if coinVisual and coinVisual:IsA("BasePart") then
			for _, child in ipairs(coinVisual:GetChildren()) do
				if child:IsA("BasePart") and child.Transparency > 0.1 then
					return false -- Already collected
				end
			end
		end
	end

	return true
end

-- Get closest coin by scanning all descendants
local function getClosestCoin(hrp)
	local closest, shortestDist = nil, math.huge
	for _, descendant in ipairs(workspace:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant.Name == "Coin_Server" then
			-- Skip invalid coins
			if isCoinValid(descendant) then
				local dist = (hrp.Position - descendant.Position).Magnitude
				-- Apply distance threshold to limit the detection range
				if dist < shortestDist and dist < MIN_DISTANCE then
					shortestDist = dist
					closest = descendant
				end
			end
		end
	end
	return closest
end

-----------------------------------
-- MOVEMENT LOGIC
-----------------------------------
local function moveContinuously(char)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local dirVel = Vector3.zero
	local rotVel = Vector3.zero
	local forward = hrp.CFrame.LookVector
	local targetCoin = nil

	while char.Parent do
		local dt = RunService.Heartbeat:Wait()

		-- Refresh target coin if none or invalid
		if not targetCoin or not targetCoin:IsDescendantOf(workspace) or not isCoinValid(targetCoin) then
			targetCoin = getClosestCoin(hrp)
		end

		-- Move toward coin if valid coin is found within range
		if targetCoin then
			local dist = (hrp.Position - targetCoin.Position).Magnitude
			local radius = targetCoin.Size.Magnitude / 2 + COIN_BUFFER
			if dist <= radius then
				-- Mark coin as collected (fade children)
				for _, child in ipairs(targetCoin:GetChildren()) do
					if child:IsA("BasePart") then
						child.Transparency = 0.5
						child.CanCollide = false
					end
				end
				-- Nullify targetCoin to stop movement towards it
				targetCoin = nil
			else
				local desiredDir = (targetCoin.Position - hrp.Position).Unit
				local dVel = desiredDir - forward
				local steerAccel = dVel * STEER_SPRING
				dirVel = (dirVel + steerAccel * dt) * math.exp(-STEER_DAMP * dt)
				forward = (forward + dirVel * dt).Unit

				local dLook = forward - hrp.CFrame.LookVector
				local aLook = dLook * ROT_SPRING
				rotVel = (rotVel + aLook * dt) * math.exp(-ROT_DAMP * dt)
				local lookDir = (hrp.CFrame.LookVector + rotVel * dt).Unit

				local newPos = hrp.Position + forward * MAX_SPEED * dt
				hrp.CFrame = CFrame.new(newPos, newPos + lookDir)
			end
		end
	end
end

-----------------------------------
-- NOCLIP & GRAVITY
-----------------------------------
local Noclip = nil
local Clip = nil

function noclip()
	Clip = false
	local function Nocl()
		if not Clip and player.Character then
			for _,v in pairs(player.Character:GetDescendants()) do
				if v:IsA("BasePart") then
					v.CanCollide = false
				end
			end
		end
	end
	Noclip = RunService.Stepped:Connect(Nocl)
end

function clip()
	if Noclip then Noclip:Disconnect() end
	Clip = true
end

noclip()

-----------------------------------
-- CHARACTER INIT + RESPAWN HOOK
-----------------------------------
local function onCharacterAdded(char)
	local humanoid = char:WaitForChild("Humanoid")
	local hrp = char:WaitForChild("HumanoidRootPart")

	workspace.Gravity = 0
	humanoid.PlatformStand = true

	task.defer(function()
		moveContinuously(char)
	end)
end

if player.Character then
	onCharacterAdded(player.Character)
end

player.CharacterAdded:Connect(onCharacterAdded)
