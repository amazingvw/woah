-----------------------------------
-- CONFIGURATION
-----------------------------------
local MAX_SPEED         = 22.7
local COIN_BUFFER       = 1
local MAX_COIN_DISTANCE = 150

local STEER_SPRING  = 45
local STEER_DAMP    = 1
local ROT_SPRING    = 700
local ROT_DAMP      = 10

local VISUAL_COIN_LIMIT    = 40
local NONVISUAL_COIN_LIMIT = 20

-----------------------------------
-- SERVICES
-----------------------------------
local Players           = game:GetService("Players")
local RunService        = game:GetService("RunService")
local UserInputService  = game:GetService("UserInputService")
local StarterGui        = game:GetService("StarterGui")

local player = Players.LocalPlayer

-----------------------------------
-- COIN COUNTERS
-----------------------------------
local visualCount    = 0
local nonVisualCount = 0

-----------------------------------
-- COIN VALIDATION
-----------------------------------
local function isCoinValid(coinPart)
	if not coinPart:IsA("BasePart") or coinPart.Name ~= "Coin_Server" then
		return false
	end

	-- Check if any visible child (direct or under CoinVisual) remains
	for _, descendant in ipairs(coinPart:GetDescendants()) do
		if descendant:IsA("BasePart") and descendant.Transparency <= 0.1 then
			return true
		end
	end
	return false
end

local function getClosestCoin(hrp)
	local closest, shortestDist = nil, math.huge
	for _, part in ipairs(workspace:GetDescendants()) do
		if part:IsA("BasePart") and part.Name == "Coin_Server" then
			if isCoinValid(part) then
				local dist = (hrp.Position - part.Position).Magnitude
				if dist <= MAX_COIN_DISTANCE and dist < shortestDist then
					shortestDist = dist
					closest = part
				end
			end
		end
	end
	return closest
end

-----------------------------------
-- MOVEMENT & COLLECTION
-----------------------------------
local function moveContinuously(char)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local humanoid = char:FindFirstChildWhichIsA("Humanoid") or char:WaitForChild("Humanoid")

	local dirVel    = Vector3.zero
	local rotVel    = Vector3.zero
	local forward   = hrp.CFrame.LookVector
	local targetCoin

	while char.Parent do
		local dt = RunService.Heartbeat:Wait()

		-- Refresh target if invalid or collected
		if not targetCoin or not targetCoin:IsDescendantOf(workspace) or not isCoinValid(targetCoin) then
			targetCoin = getClosestCoin(hrp)
		end

		-- If we have a target, move toward it
		if targetCoin then
			local dist   = (hrp.Position - targetCoin.Position).Magnitude
			local radius = targetCoin.Size.Magnitude/2 + COIN_BUFFER

			if dist <= radius then
				-- MARK COLLECTED: fade all children
				for _, descendant in ipairs(targetCoin:GetDescendants()) do
					if descendant:IsA("BasePart") then
						descendant.Transparency = 0.5
						descendant.CanCollide  = false
					end
				end

				-- INCREMENT COUNTER
				-- If any child named "CoinVisual" exists, count as visual; else non-visual
				local isVisual = false
				for _, child in ipairs(targetCoin:GetChildren()) do
					if child.Name == "CoinVisual" then
						isVisual = true
						break
					end
				end

				if isVisual then
					visualCount = visualCount + 1
				else
					nonVisualCount = nonVisualCount + 1
				end

				-- CHECK LIMITS
				if visualCount >= VISUAL_COIN_LIMIT and nonVisualCount >= NONVISUAL_COIN_LIMIT then
					humanoid.Health = 0
					return
				end

				-- Clear target
				targetCoin = nil

			else
				-- STEERING
				local desiredDir = (targetCoin.Position - hrp.Position).Unit
				local dVel       = desiredDir - forward
				local steerAccel = dVel * STEER_SPRING

				dirVel  = (dirVel + steerAccel * dt) * math.exp(-STEER_DAMP * dt)
				forward = (forward + dirVel * dt).Unit

				-- ROTATION
				local dLook = forward - hrp.CFrame.LookVector
				local aLook = dLook * ROT_SPRING

				rotVel  = (rotVel + aLook * dt) * math.exp(-ROT_DAMP * dt)
				local lookDir = (hrp.CFrame.LookVector + rotVel * dt).Unit

				-- APPLY MOVEMENT
				local newPos = hrp.Position + forward * MAX_SPEED * dt
				hrp.CFrame = CFrame.new(newPos, newPos + lookDir)
			end
		end
	end
end

-----------------------------------
-- NOCLIP & ZERO GRAVITY
-----------------------------------
local noclipConnection
local clipFlag = false

local function noclip()
	clipFlag = false
	if noclipConnection then noclipConnection:Disconnect() end
	noclipConnection = RunService.Stepped:Connect(function()
		if not clipFlag and player.Character then
			for _, part in pairs(player.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = false
				end
			end
		end
	end)
end

local function clip()
	clipFlag = true
	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end
end

noclip()

-----------------------------------
-- KEYBIND: 'P' SHOW COUNTS
-----------------------------------
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.KeyCode == Enum.KeyCode.P then
		StarterGui:SetCore("SendNotification", {
			Title = "Coins Collected";
			Text  = string.format("Visual: %d/%d  |  Non-Visual: %d/%d",
				visualCount, VISUAL_COIN_LIMIT,
				nonVisualCount, NONVISUAL_COIN_LIMIT);
			Duration = 3;
		})
	end
end)

-----------------------------------
-- CHARACTER RESPAWN HANDLING
-----------------------------------
local function onCharacterAdded(char)
	-- Reset counters
	visualCount    = 0
	nonVisualCount = 0

	-- Zero gravity and disable default movement
	local humanoid = char:WaitForChild("Humanoid")
	humanoid.PlatformStand = true
	workspace.Gravity = 0

	-- Start movement coroutine
	task.defer(function()
		moveContinuously(char)
	end)
end

-- INITIAL HOOK
if player.Character then
	onCharacterAdded(player.Character)
end
player.CharacterAdded:Connect(onCharacterAdded)
