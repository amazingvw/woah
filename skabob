-----------------------------------
-- CONFIGURATION
-----------------------------------
local MAX_SPEED         = 22.6
local COIN_BUFFER       = 1
local MAX_COIN_DISTANCE = 400

local TARGET_COIN_SIZE  = Vector3.new(1.75, 6, 1.75)
local COIN_VISUAL_OFFSET = Vector3.new(0, -2.5, 0)

-----------------------------------
-- SERVICES
-----------------------------------
local Players    = game:GetService("Players")
local RunService = game:GetService("RunService")
local player     = Players.LocalPlayer
local ws         = workspace
local terrain    = ws:FindFirstChildOfClass("Terrain")

-----------------------------------
-- COIN VALIDATION
-----------------------------------
local function isCoinValid(coinPart)
	if not coinPart:IsA("BasePart") or coinPart.Name ~= "Coin_Server" then
		return false
	end
	local vis = coinPart:FindFirstChild("CoinVisual")
	return vis and vis:IsA("BasePart") and vis.Transparency <= 0.1
end

local function getClosestCoin(hrp)
	local closest, shortestDist = nil, math.huge
	for _, desc in ipairs(ws:GetDescendants()) do
		if desc:IsA("BasePart") and desc.Name == "Coin_Server" and isCoinValid(desc) then
			local dist = (hrp.Position - desc.Position).Magnitude
			if dist < shortestDist and dist <= MAX_COIN_DISTANCE then
				shortestDist = dist
				closest = desc
			end
		end
	end
	return closest
end

-----------------------------------
-- MOVEMENT & COLLECTION
-----------------------------------
local function moveContinuously(char)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local rootModel = char

	local targetCoin
	local rotateTimer = 0

	while char.Parent do
		local dt = RunService.Heartbeat:Wait()
		rotateTimer += dt

		-- Re-evaluate target coin
		if not targetCoin or not targetCoin:IsDescendantOf(ws) or not isCoinValid(targetCoin) then
			targetCoin = getClosestCoin(hrp)
			if targetCoin then
				targetCoin.Size = TARGET_COIN_SIZE
			end
		end

		if targetCoin then
			local vis = targetCoin:FindFirstChild("CoinVisual")
			if vis then
				local targetPos = Vector3.new(vis.Position.X, vis.Position.Y + COIN_VISUAL_OFFSET.Y, vis.Position.Z)
				local dist = (hrp.Position - targetPos).Magnitude
                                if dist <= 0.5 then
                                    for _, p in ipairs(targetCoin:GetDescendants()) do
                                        if p:IsA("BasePart") then
                                            p.Transparency = 0.5
                                            p.CanCollide = false
                                        end
                                    end
                                    targetCoin = nil

				else
					local direction = (targetPos - hrp.Position).Unit
					local newPos = hrp.Position + direction * MAX_SPEED * dt
					local moveDelta = newPos - hrp.Position
					rootModel:PivotTo(rootModel:GetPivot() + moveDelta)
				end
			end
		end

		-- Apply global rotation every second
		if rotateTimer >= 1 then
			rotateTimer = 0
			local pivot = rootModel:GetPivot()
			rootModel:PivotTo(CFrame.new(pivot.Position) * CFrame.Angles(math.rad(90), 0, 0))
		end
	end
end

-----------------------------------
-- NOCLIP
-----------------------------------
RunService.Stepped:Connect(function()
	if player.Character then
		for _, v in ipairs(player.Character:GetDescendants()) do
			if v:IsA("BasePart") then
				v.CanCollide = false
			end
		end
	end
end)

-----------------------------------
-- CHARACTER INIT + RESPAWN
-----------------------------------
local function onCharacterAdded(char)
	local humanoid = char:WaitForChild("Humanoid")
	local hrp = char:WaitForChild("HumanoidRootPart")

	workspace.Gravity = 0
	humanoid.PlatformStand = true

	task.delay(0.5, function()
		if hrp and hrp:IsDescendantOf(workspace) then
			-- Teleport character 10 studs below current position
			local pivot = char:GetPivot()
			char:PivotTo(CFrame.new(pivot.Position - Vector3.new(0, 10, 0)))
			-- Zero out motion
                        wait(0.1)
			hrp.AssemblyLinearVelocity = Vector3.zero
			hrp.AssemblyAngularVelocity = Vector3.zero
		end
	end)

	local coinsTextLabel = player:WaitForChild("PlayerGui")
		:WaitForChild("MainGUI")
		:WaitForChild("Game")
		:WaitForChild("CoinBags")
		:WaitForChild("Container")
		:WaitForChild("BeachBall")
		:WaitForChild("CurrencyFrame")
		:WaitForChild("Icon")
		:WaitForChild("Coins")

	local function onTextChanged()
		if tonumber(coinsTextLabel.Text) == 40 then
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hum then
				hum.Health = 0
			end
		end
	end

	coinsTextLabel:GetPropertyChangedSignal("Text"):Connect(onTextChanged)
	onTextChanged()

	task.defer(function()
		moveContinuously(char)
	end)
end

if player.Character then
	onCharacterAdded(player.Character)
end
player.CharacterAdded:Connect(onCharacterAdded)

-----------------------------------
-- CLEANUP & MAP FILTER
-----------------------------------
local function isMapModel(m)
	if not m:IsA("Model") then return false end
	return m:FindFirstChild("Base") or m:FindFirstChild("CoinContainer") or m:FindFirstChild("CoinAreas")
end

local function cleanMapModel(m)
	for _, c in ipairs(m:GetChildren()) do
		if c.Name ~= "CoinContainer" and c.Name ~= "CoinAreas" then
			c:Destroy()
		end
	end
end

local function sweepWorkspace()
	for _, obj in ipairs(ws:GetChildren()) do
		if obj == player.Character or obj == terrain or obj:IsA("Camera") then
			continue
		elseif isMapModel(obj) then
			cleanMapModel(obj)
		else
			obj:Destroy()
		end
	end
end

local function onChildAdded(obj)
	RunService.Heartbeat:Wait()

	if obj == player.Character or obj == terrain or obj:IsA("Camera") then
		return
	elseif isMapModel(obj) then
		cleanMapModel(obj)
	else
		obj:Destroy()
	end
end

player.CharacterAdded:Connect(function(char)
	char:WaitForChild("HumanoidRootPart", 5)
	sweepWorkspace()
end)

ws.ChildAdded:Connect(onChildAdded)

if player.Character then
	sweepWorkspace()
end










-- Teleportation check: detect if character moves >400 studs, then move down 10 studs
player.CharacterAdded:Connect(function(char)
	task.spawn(function()
		local hrp = char:WaitForChild("HumanoidRootPart")
		local lastPosition = hrp.Position

		while char.Parent do
			RunService.Heartbeat:Wait()

			local currentPosition = hrp.Position
			local distance = (currentPosition - lastPosition).Magnitude

			if distance >= 400 then
				local pivot = char:GetPivot()
				char:PivotTo(CFrame.new(pivot.Position - Vector3.new(0, 10, 0)))
				print("Character teleported over 400 studs â€” moved down by 10 studs.")
			end

			lastPosition = currentPosition
		end
	end)
end)







local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- The path to the Coins TextLabel, from your earlier example
local coinsTextLabel = playerGui:WaitForChild("MainGUI")
	:WaitForChild("Game")
	:WaitForChild("CoinBags")
	:WaitForChild("Container")
	:WaitForChild("BeachBall")
	:WaitForChild("CurrencyFrame")
	:WaitForChild("Icon")
	:WaitForChild("Coins")

-- Constants
local MAX_BAG = 40

-- Persistent session data stored as Attributes on PlayerGui (session only)
local function getStat(name)
	return playerGui:GetAttribute(name) or 0
end
local function setStat(name, value)
	playerGui:SetAttribute(name, value)
end

-- Initialize stats if not set
if getStat("SuccessfulResets") == 0 then
	setStat("SuccessfulResets", 0)
end
if getStat("Deaths") == 0 then
	setStat("Deaths", 0)
end
if getStat("TotalCoins") == 0 then
	setStat("TotalCoins", 0)
end

-- Create the GUI Frame
local frame = Instance.new("Frame")
frame.Name = "StatsFrame"
frame.AnchorPoint = Vector2.new(0, 0)
frame.Position = UDim2.new(0.01, 0, 0.01, 0)
frame.Size = UDim2.new(0, 220, 0, 120)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BackgroundTransparency = 0.3
frame.BorderSizePixel = 0
frame.Parent = playerGui

-- UIListLayout for vertical alignment and padding
local layout = Instance.new("UIListLayout")
layout.Parent = frame
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 6)

-- Helper function: create a text label with responsive sizing
local function createLabel(text)
	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Size = UDim2.new(1, -10, 0, 20) -- Full width minus padding, fixed height
	label.Font = Enum.Font.GothamBold
	label.Parent = frame
	return label
end

local bagLabel = createLabel("Bag: 0/" .. MAX_BAG)
local resetsLabel = createLabel("Successful Resets: 0")
local deathsLabel = createLabel("Deaths: 0")
local totalCoinsLabel = createLabel("Total Coins: 0")

-- Responsive update function based on frame size
local function updateResponsive()
	-- Adjust text size based on frame height (simple logic)
	local labelCount = 4
	local labelHeight = (frame.AbsoluteSize.Y - layout.Padding.Offset * (labelCount - 1)) / labelCount
	local textSize = math.clamp(labelHeight * 0.6, 12, 20) -- clamp between 12 and 20

	for _, label in ipairs(frame:GetChildren()) do
		if label:IsA("TextLabel") then
			label.TextSize = textSize
			label.Size = UDim2.new(1, -10, 0, labelHeight)
		end
	end
end

frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateResponsive)
RunService.Heartbeat:Connect(updateResponsive)
updateResponsive()

-- Variables to track deaths and respawns
local character = localPlayer.Character
local humanoid = character and character:FindFirstChildOfClass("Humanoid")

local function updateLabels()
	local coins = tonumber(coinsTextLabel.Text) or 0
	bagLabel.Text = string.format("Bag: %d/%d", coins, MAX_BAG)
	resetsLabel.Text = "Successful Resets: " .. getStat("SuccessfulResets")
	deathsLabel.Text = "Deaths: " .. getStat("Deaths")
	totalCoinsLabel.Text = "Total Coins: " .. getStat("TotalCoins")
end

-- Update total coins collected when coins increase (session total)
local lastCoinAmount = 0
coinsTextLabel:GetPropertyChangedSignal("Text"):Connect(function()
	local currentCoins = tonumber(coinsTextLabel.Text) or 0
	if currentCoins > lastCoinAmount then
		local totalCoins = getStat("TotalCoins")
		setStat("TotalCoins", totalCoins + (currentCoins - lastCoinAmount))
	end
	lastCoinAmount = currentCoins
	updateLabels()
end)

updateLabels()

-- Track deaths before reset
local function onHumanoidDied()
	-- Increase death count only if bag isn't full yet
	if tonumber(coinsTextLabel.Text) < MAX_BAG then
		local deaths = getStat("Deaths")
		setStat("Deaths", deaths + 1)
		updateLabels()
	end
end

-- Track successful resets (when bag reaches full)
local function onBagFull()
	local successfulResets = getStat("SuccessfulResets")
	setStat("SuccessfulResets", successfulResets + 1)
	setStat("Deaths", 0)  -- reset deaths count for next run
	updateLabels()
end

-- Listen to humanoid Died event, update on character respawn
local function onCharacterAdded(char)
	character = char
	humanoid = character:WaitForChild("Humanoid")

	humanoid.Died:Connect(onHumanoidDied)

	-- Reset local tracking variables
	lastCoinAmount = tonumber(coinsTextLabel.Text) or 0
	updateLabels()
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)
if localPlayer.Character then
	onCharacterAdded(localPlayer.Character)
end

-- Listen for bag full condition
coinsTextLabel:GetPropertyChangedSignal("Text"):Connect(function()
	local coins = tonumber(coinsTextLabel.Text) or 0
	if coins >= MAX_BAG then
		onBagFull()
	end
end)

