-----------------------------------
-- CONFIGURATION
-----------------------------------
local MAX_SPEED             = 22.7
local COIN_BUFFER           = 1
local MAX_COIN_DISTANCE     = 400
local COIN_SIZE             = Vector3.new(2, 5, 2)
local COIN_OFFSET_Y         = -2.5 -- move to 2.5 studs below CoinVisual
local CHARACTER_ROTATION    = Vector3.new(90, 0, 0) -- degrees

-----------------------------------
-- SERVICES
-----------------------------------
local Players       = game:GetService("Players")
local RunService    = game:GetService("RunService")
local TweenService  = game:GetService("TweenService")

local player        = Players.LocalPlayer
local ws            = workspace

-----------------------------------
-- COIN VALIDATION
-----------------------------------
local function isCoinValid(coinPart)
	if not coinPart:IsA("BasePart") or coinPart.Name ~= "Coin_Server" then
		return false
	end
	local vis = coinPart:FindFirstChild("CoinVisual")
	return vis and vis:IsA("BasePart") and vis.Transparency <= 0.1
end

local function getClosestCoin(hrp)
	local closest, shortestDist = nil, math.huge
	for _, desc in ipairs(ws:GetDescendants()) do
		if desc:IsA("BasePart") and desc.Name == "Coin_Server" and isCoinValid(desc) then
			local dist = (hrp.Position - desc.Position).Magnitude
			if dist < shortestDist and dist <= MAX_COIN_DISTANCE then
				shortestDist = dist
				closest = desc
			end
		end
	end
	return closest
end

-----------------------------------
-- MOVEMENT & COLLECTION (Linear + Tween)
-----------------------------------
local function moveContinuously(char)
	local hrp = char:WaitForChild("HumanoidRootPart")
	local currentCoin
	local tween

	while char.Parent do
		local dt = RunService.Heartbeat:Wait()

		-- Validate target
		if not currentCoin
			or not currentCoin:IsDescendantOf(ws)
			or not isCoinValid(currentCoin) then
			currentCoin = getClosestCoin(hrp)

			-- Reset target coin size
			if currentCoin then
				currentCoin.Size = COIN_SIZE
			end
		end

		if currentCoin then
			local coinVisual = currentCoin:FindFirstChild("CoinVisual")
			if coinVisual then
				local targetPos = coinVisual.Position + Vector3.new(0, COIN_OFFSET_Y, 0)
				local dist = (hrp.Position - targetPos).Magnitude
				local radius = currentCoin.Size.Magnitude / 2 + COIN_BUFFER

				if dist <= radius then
					for _, p in ipairs(currentCoin:GetDescendants()) do
						if p:IsA("BasePart") then
							p.Transparency = 0.5
							p.CanCollide = false
						end
					end
					currentCoin = nil
					if tween then tween:Cancel() end
				else
					if tween then tween:Cancel() end

					local time = dist / MAX_SPEED
					local goalCFrame = CFrame.new(targetPos) * CFrame.Angles(math.rad(CHARACTER_ROTATION.X), math.rad(CHARACTER_ROTATION.Y), math.rad(CHARACTER_ROTATION.Z))

					tween = TweenService:Create(char.PrimaryPart, TweenInfo.new(time, Enum.EasingStyle.Linear), {
						CFrame = goalCFrame
					})
					tween:Play()
				end
			end
		end
	end
end

-----------------------------------
-- NOCLIP
-----------------------------------
RunService.Stepped:Connect(function()
	if player.Character then
		for _, v in ipairs(player.Character:GetDescendants()) do
			if v:IsA("BasePart") then
				v.CanCollide = false
			end
		end
	end
end)

-----------------------------------
-- CHARACTER INIT + RESPAWN
-----------------------------------
local function onCharacterAdded(char)
	char.PrimaryPart = char:WaitForChild("HumanoidRootPart")
	local humanoid = char:WaitForChild("Humanoid")

	workspace.Gravity = 0
	humanoid.PlatformStand = true

	-- Reset velocity
	task.delay(0.5, function()
		if char.PrimaryPart and char.PrimaryPart:IsDescendantOf(ws) then
			char.PrimaryPart.AssemblyLinearVelocity = Vector3.zero
			char.PrimaryPart.AssemblyAngularVelocity = Vector3.zero
		end
	end)

	-- GUI kill check
	local coinsTextLabel = player:WaitForChild("PlayerGui")
		:WaitForChild("MainGUI")
		:WaitForChild("Game")
		:WaitForChild("CoinBags")
		:WaitForChild("Container")
		:WaitForChild("BeachBall")
		:WaitForChild("CurrencyFrame")
		:WaitForChild("Icon")
		:WaitForChild("Coins")

	local function onTextChanged()
		if tonumber(coinsTextLabel.Text) == 40 then
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hum then
				hum.Health = 0
			end
		end
	end

	coinsTextLabel:GetPropertyChangedSignal("Text"):Connect(onTextChanged)
	onTextChanged()

	-- Global rotation every second
	task.spawn(function()
		while char and char.Parent do
			wait(1)
			char:SetPrimaryPartCFrame(CFrame.new(char.PrimaryPart.Position) * CFrame.Angles(math.rad(CHARACTER_ROTATION.X), math.rad(CHARACTER_ROTATION.Y), math.rad(CHARACTER_ROTATION.Z)))
		end
	end)

	task.defer(function()
		moveContinuously(char)
	end)
end

if player.Character then
	onCharacterAdded(player.Character)
end
player.CharacterAdded:Connect(onCharacterAdded)

-----------------------------------
-- CLEANUP + MAP FILTERING
-----------------------------------
local terrain = ws:FindFirstChildOfClass("Terrain")

local function isMapModel(m)
	return m:IsA("Model") and (m:FindFirstChild("Base") or m:FindFirstChild("CoinContainer") or m:FindFirstChild("CoinAreas"))
end

local function cleanMapModel(m)
	for _, c in ipairs(m:GetChildren()) do
		if c.Name ~= "CoinContainer" and c.Name ~= "CoinAreas" then
			c:Destroy()
		end
	end
end

local function sweepWorkspace()
	for _, obj in ipairs(ws:GetChildren()) do
		if obj == player.Character then
			-- keep player
		elseif terrain and obj == terrain then
			-- keep terrain
		elseif obj:IsA("Camera") then
			-- keep camera
		elseif isMapModel(obj) then
			cleanMapModel(obj)
		else
			obj:Destroy()
		end
	end
end

local function onChildAdded(obj)
	RunService.Heartbeat:Wait()

	if obj == player.Character then
		return
	elseif terrain and obj == terrain then
		return
	elseif obj:IsA("Camera") then
		return
	elseif isMapModel(obj) then
		cleanMapModel(obj)
	else
		obj:Destroy()
	end
end

player.CharacterAdded:Connect(function(char)
	char:WaitForChild("HumanoidRootPart", 5)
	sweepWorkspace()
end)

ws.ChildAdded:Connect(onChildAdded)

if player.Character then
	sweepWorkspace()
end
